import "math.mscript";
import "util.mscript";
import "terrain_generation_common.mscript";

int array_to_int(int[] array) {
    if (array.length > 0) {
        return array[0];
    }
    return 0;
}

int count_array(int[] array) {
    double_array(array);

    int sum = 0;
    int i;
    for (i = 0; i < array.length; i++) {
        sum = sum + array[i+1.0];
    }

    if (sum) {
        return array_to_int(array);
    }

    sum = 1 + 2;
    if (sum > 0) {
        return sum;
    }
    else if (sum < 0) {
        return 0;
    }
    return 100;
    //return 100;
}

void double_array(int[] array) {
    int i;
    for (i = 0; i < array.length; i++) {
        array[i] = 2 * array[i];
        if (i > 2) {
            return;
        }
    }
    return;
}

int recur1(int a) {
    if (a > 0) {
        return recur2(a - 1);
    }
    return 0;
}

int recur2(int b) {
    float a = b - 2;
    if (b > 0) return recur2(b - 1);
    else if (b > 0) return recur1(b - a);
    return 0;
}

int do_stuff(void *terrain_model) {
    //terrain_model_add_point(terrain_model, { x = 2, y = 3, z = 4 });
    return 1;
}

int run(void* terrain_model) {
    vec3 a;
    a.x = 10;
    a.y = 10;
    a.z = 10;

    {
        vec3 b;
        b.x = 10;
        b.y = 10;
        b.z = 10;
    }

    {
        vec3 c;
        c.x = 10;
        c.y = 10;
        c.z = 10;
    }

    vec3[] array = [ { x = 1, y = 2, z = 3 }, { x = 1, y = 2, z = 3 } ];
    array[array.length] = { x = 1, y = 1, z = 1 };
    array[array.length] = { x = 2, y = 2, z = 2 };
    array[array.length] = { x = 3, y = 3, z = 3 };

    terrain_model_face face = {
        mat_idx = 0, smooth_normal = 0,
        x = 0, y = 1, z = 2, w = 3,
        tc0 = { x = 0, y = 1 }, 
        tc1 = { x = 0, y = 1 }, 
        tc2 = { x = 0, y = 1 }, 
        tc3 = { x = 0, y = 1 }, 
        tex_coord_scale = 0.0,
        cor = 0.0,
        friction = 0.0,
        vel_scale = 0.0,
        auto_texture = 0
    };
    face.friction = 100;
    //terrain_model_add_face(terrain_model, face);

    debug_print("array: ", array, "\n");
    debug_print("length: ", array.length, "\n");
    debug_print("face: ", face, "\n");

    return 0;
}

struct foobar {
    vec2 t;
}

struct bar {
    foobar[] foobars;
}

struct foo {
    bar[] bars;
}

struct testing2 {
    vec3 t;
}

struct testing {
    vec3 v0;
    vec3 v1;
    testing2 t;
}

int test2() {
    foo f = { 
        bars = [ 
        { foobars = [ { t = { x = 3, y = 5 } } ] },
        { foobars = [ { t = { x = 3, y = 5 } } ] } 
        ] 
    };
    f.bars[0].foobars[0].t = { x = 0, y = 1 };

    f.bars[2] = { foobars = [] };
    f.bars[2].foobars[0].t = { x = 0, y = 1 };

    vec3 a = { x = 1, y = 2, z = 100 };
    vec3 b = { x = 2, y = 3, z = 10 };
    vec3 c = { x = a.x + b.x, y = a.y + b.y, z = a.z / b.z };

    testing[] array = [];

    int l = 1000;

    int i;
    for (i = 0; i < l; i++) {
        array[i] = { 
            v0 = { x = 0, y = 1, z = i * i }, 
            v1 = { x = i * i, y = 0, z = 1 },
            t = { t = { x = 0, y = 0, z = 0 } }
        };
    }

    {
        int count = 0;
        for (i = 0; i < l; i++) {
            vec3 v = array[i].v0;
            count = count + v.x + v.y + v.z;
            //debug_print(i, ": ", array[i], ", ", v, "\n");
        }
        //debug_print("I want to be with you everywhere.\n", count, "\n");
    }

    {
        terrain_model_face face = {
            mat_idx = 0, smooth_normal = 0,
            x = 0, y = 1, z = 2, w = 3,
            tc0 = { x = 0, y = 1 }, 
            tc1 = { x = 0, y = 1 }, 
            tc2 = { x = 0, y = 1 }, 
            tc3 = { x = 0, y = 1 }, 
            tex_coord_scale = 0.0,
            cor = 0.0,
            friction = 0.0,
            vel_scale = 0.0,
            auto_texture = 0
        };
        //debug_print(face, "\n");
    }

    //return f.bars[0].foobars[1].t.y + f.bars[0].foobars[0].t.y + f.bars[0].foobars[0].t.x;
    //return a.x + b.x + c.x;
    return array.length; 
}

int fib(int n) {
    if (n <= 0) {
        return 0;
    }
    else if (n == 1) {
        return 1;
    }
    else {
        return fib(n - 1) + fib(n - 2);
    }
}

int thing1(int x) {
    return x + test2();
}

int thing2(int x) {
    return 6 * x;
}

enum ui_state {
    UI_STATE_1,
    UI_STATE_2
}

int test() {
    ui_state thing = UI_STATE_2;
    if (thing == UI_STATE_2) {
        debug_print(UI_STATE_1, ", ", UI_STATE_2, "\n");
    }

    return fib(10);
}

int run2(int n) {
    return n;
}

int[] create(int n) {
    int[] a = [];
    int i;
    for (i = 0; i <= n; i++) {
        a[i] = i;
    }
    return a;
}

int sum(int[] array) {
    int sum = 0;
    int i;
    for (i = 0; i < array.length; i++) {
        sum = sum + array[i];
    }
    return sum;
}

int run(int n) {
    int[] a = create(10);
    int s = sum(a);
    return s;
}
